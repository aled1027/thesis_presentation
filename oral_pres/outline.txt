# Outline
- 2PC
    - general problem: secure computation
    - we look at two party case, 2PC
    - what is it?
        - two parties compute f
        - millionaire problem
    - why is it useful?
        - auction, election, genome analysis, two companies
    - security
        - properties
            - privacy
            - correctness
        - setting
            semi-honest
        - maybe explain comp indist
        - maybe explain security parameter
- Garbled Circuits
    - primitives
        - enc
        - ot
            - have RSA based if asked
    - the protocol (have slide)
        - Garble
            - Assign wire labels
            - Make garbled tables
        - Communicate
            - Send garbled tables
            - Send input wire labels
        - Evaluate
            - trial decrypt
            - acquire output wire label
            - Uses output wire label
    - mention security
    - complexity/cost
- Improvements to Garbled Circuits
    - Point and Permute
    - GRR3
    - Free XOR
    - GRR2
        - skip
    - FleXOR
        - board-work if necessary
    - Half gates
        - board-work -- walk through paper
    - Improving OT
- Component-Based Garbled Circuits + SCMC
    - history
        - partial garbled circuits
             - retaining state to prevent needless reprocessing
             - they work in semi-honest and malicious (adds extra steps)
             - method
                - transform W_i^0 and W_i^1 into W_j^0 and W_j^1
                - they send W_i^0 \oplus W_j^0 and W_i^1 \oplus W_j^1 with point and permute
                - xor as indicated by PP select bit. 
                - this generates valid input wire label
             - built friend-finder
                - friends send their location to server
                - say which "grid" they are in
                - server computes which friends are near each other (think set intersection with bitwise thing)
                - a friend moves, and server recomputes who is near each other without getting locations from friends who didn't move
    - motivating
        - offline/ online
        - function chosen ahead of time
        - no flexibility
    - Naive linking
    - SCMC
- Implementation and Results
    - discuss how code works
        - C
        - function specification
    - Experiments
        - aes 
            - commonly measured
            - might encrypt output of a function
            - component: aes round
        - cbc
            - had aes working, so not too hard to do
            - arbitrary size
            - component: aes round and xor
        - levenshtein
            - genomic analysis
            - dynamic algo so single component: levenshtein core
            - 30 and 60 symbols
            - 8 bit alphabet
                - so not DNA, but what lit used
    - Results
        - table with load
        - table no load
        - naive verse scmc
- future work
    - malicious setting
    - mpc - more than two parties
    - make linking faster
    - reduce memory footprint
    - develop library of components

# Orals TODO
- Poker example
- Check CompGC paper on meaning of i in SCMC
- check partial gcs paper

# Writing TODO
- there exist(s) in encryption security definition
- type top page 22:
    - {view A (x, y)} x,y∈{0,1} ∗ }
    - extra }
- 2pc security definition
    - why are (S_1) and S_2 surrounded by parentheses?
    - they are not a tuple
    - \{(S_1(x, f_1(x,y), f(x,y)))\}_{x,y} \compindist \{(\viewrv^{\Pi}_1(x,y), \outputrv^{\Pi}(x,y)) \}_{x,y} \\
- 2pc security definition
    - check goldreich definition
    - are f_1 and f supposed to be inputs to simulators???
    - I say that they only take two inputs before
    - I think they are supposed to be there, but the parentheses are off
- GRR3 example is *not* an AND gate.


